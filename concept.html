<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>概念 | MicroDevelopment - 微开发</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="基于微服务思想，融合模块化方式，衍生的一种新型开发方式。">
    <link rel="preload" href="/assets/css/0.styles.7d2c80c1.css" as="style"><link rel="preload" href="/assets/js/app.921ab5f8.js" as="script"><link rel="preload" href="/assets/js/2.f6d0a541.js" as="script"><link rel="preload" href="/assets/js/7.1e601e68.js" as="script"><link rel="prefetch" href="/assets/js/10.b8364669.js"><link rel="prefetch" href="/assets/js/3.1fec26ea.js"><link rel="prefetch" href="/assets/js/4.724462bb.js"><link rel="prefetch" href="/assets/js/5.9968e306.js"><link rel="prefetch" href="/assets/js/6.36851cb3.js"><link rel="prefetch" href="/assets/js/8.3604ab5e.js"><link rel="prefetch" href="/assets/js/9.92d3e82f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7d2c80c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">MicroDevelopment - 微开发</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/quickStart.html" class="nav-link">
  快速开始
</a></div><div class="nav-item"><a href="/concept.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  概念
</a></div><div class="nav-item"><a href="/cli.html" class="nav-link">
  脚手架
</a></div><div class="nav-item"><a href="/question.html" class="nav-link">
  常见问题
</a></div> <a href="https://github.com/micro-development" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/quickStart.html" class="nav-link">
  快速开始
</a></div><div class="nav-item"><a href="/concept.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  概念
</a></div><div class="nav-item"><a href="/cli.html" class="nav-link">
  脚手架
</a></div><div class="nav-item"><a href="/question.html" class="nav-link">
  常见问题
</a></div> <a href="https://github.com/micro-development" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>概念</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/concept.html#索引" class="sidebar-link">索引</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/concept.html#什么是微开发？" class="sidebar-link">什么是微开发？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/concept.html#微开发模式和传统模式的区别？" class="sidebar-link">微开发模式和传统模式的区别？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/concept.html#传统模式" class="sidebar-link">传统模式</a></li><li class="sidebar-sub-header"><a href="/concept.html#微开发模式" class="sidebar-link">微开发模式</a></li></ul></li><li><a href="/concept.html#微开发和微服务的区别？" class="sidebar-link">微开发和微服务的区别？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/concept.html#共同之处" class="sidebar-link">共同之处</a></li><li class="sidebar-sub-header"><a href="/concept.html#不同之处" class="sidebar-link">不同之处</a></li><li class="sidebar-sub-header"><a href="/concept.html#对比分析" class="sidebar-link">对比分析</a></li></ul></li><li><a href="/concept.html#拓展延伸" class="sidebar-link">拓展延伸</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/concept.html#npm-cnpm" class="sidebar-link">npm/cnpm</a></li><li class="sidebar-sub-header"><a href="/concept.html#微开发" class="sidebar-link">微开发</a></li></ul></li><li><a href="/concept.html#大道至简" class="sidebar-link">大道至简</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/concept.html#技术实现" class="sidebar-link">技术实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/concept.html#源码-依赖-管理器" class="sidebar-link">源码 依赖 管理器</a></li><li class="sidebar-sub-header"><a href="/concept.html#实现依赖管理的必备条件" class="sidebar-link">实现依赖管理的必备条件</a></li><li class="sidebar-sub-header"><a href="/concept.html#仓库之间依赖注入的实现解决了什么问题？" class="sidebar-link">仓库之间依赖注入的实现解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/concept.html#编译-发布-部署" class="sidebar-link">编译&amp;&amp;发布&amp;部署</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h1> <div class="custom-block danger"><p class="custom-block-title">须知，术语定义</p> <p>由于本篇中涉及了其他知识点和一些概念，下对一些词做一个预定义解释，方便快速理解。</p></div> <ul><li>项目：如没有刻意说明，通常指 <code>git</code> 仓库</li> <li>应用：项目中 某个独立的 模块/业务/服务/功能</li> <li>底层应用：一个项目或N个应用依赖的 <code>底层逻辑</code> ，比如系统中的 <code>用户中心</code></li> <li>公共资源：不涉及 <code>应用/业务</code> 的逻辑，比如一些工具方法，插件，公用的组件，类似 <code>npm</code> 托管的包</li> <li>网关：微服务架构模式中 各个服务面向客户端交互时的中间桥梁（后面再描述）</li> <li>脚手架：命令行工具，比如常见的各种 <code>cli</code> ，提供一系列操作来简化提升一些开发效率</li></ul> <h2 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h2> <ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%BC%80%E5%8F%91">什么是微开发？</a></li> <li><a href="#%E5%BE%AE%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">微开发和传统开发的区别？</a></li> <li><a href="#%E5%BE%AE%E5%BC%80%E5%8F%91%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB">微开发和微服务的区别？</a></li> <li><a href="#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0">微开发的技术实现？</a></li></ul> <h2 id="什么是微开发？"><a href="#什么是微开发？" class="header-anchor">#</a> 什么是微开发？</h2> <p>当一个项目变得越来越庞大时，不管在维护方面，还是拓展，或构建编译等各方面，都会带来过多多少的性能瓶颈，而微开发在设计之初，则是为了解决这个问题。</p> <p>微开发借鉴了微服务思想中的抽象模式，摒弃了独立发布部署之后利用 <code>网关</code> 面向客户端请求进行路由转发的层面，来以此避免各个 <code>应用</code> 之间的耦合问题。</p> <div class="custom-block warning"><p class="custom-block-title">意外之喜</p> <p>当这个设计完成之后，意外收到了其他的好处，在下方 微开发的优点 中会提到！</p></div> <h2 id="微开发模式和传统模式的区别？"><a href="#微开发模式和传统模式的区别？" class="header-anchor">#</a> 微开发模式和传统模式的区别？</h2> <h3 id="传统模式"><a href="#传统模式" class="header-anchor">#</a> 传统模式</h3> <p><img src="https://assets.processon.com/chart_image/5f0ec3c6f346fb2bfb26ae43.png" alt="传统结构"></p> <p>通过上图可以看出结构基本如下：</p> <ul><li>一个项目包含：
<ul><li>N个应用</li> <li>一大堆公共资源</li></ul></li></ul> <p>那么，这会带来什么问题呢？</p> <ol><li>任何一个地方的代码出现致命问题，整个项目都会报错</li> <li>如果不同的应用，上线日期不同，而又依赖 <code>底层业务</code> ，将会带来很大的维护成本</li> <li>当前项目中的 <code>公用资源</code> 如何共享给其他项目使用？</li> <li>构建编译慢，虽然可以有各种方法优化</li></ol> <h3 id="微开发模式"><a href="#微开发模式" class="header-anchor">#</a> 微开发模式</h3> <p><img src="https://assets.processon.com/chart_image/5f0ec723f346fb2bfb26bebb.png" alt="微开发结构"></p> <p>通过上图可以看出结构基本如下：</p> <ul><li>N个应用拆分成N个项目</li> <li>底层应用一个项目</li> <li>公共资源一个项目</li></ul> <p>那么，这能解决什么问题呢？</p> <ol><li>任何一个地方的代码出现致命问题，其他都是独立的仓库，怎么也影响不到了。</li> <li>如果不同的应用，依赖 <code>底层应用</code> ，上线日期也不同，又需要修改 <code>底层应用</code> ，直接开分支进行注入即可。</li> <li>当前项目中的 <code>公用资源</code> ，其他项目用同样的方式，直接注入即可。</li> <li>仅仅 把自身 <code>应用</code> 和依赖的 <code>底层应用</code> 进行构建编译即可。</li></ol> <h2 id="微开发和微服务的区别？"><a href="#微开发和微服务的区别？" class="header-anchor">#</a> 微开发和微服务的区别？</h2> <div class="custom-block tip"><p class="custom-block-title">说明</p> <p><strong>微开发</strong> 和 <strong>微服务</strong> 其实是有一些异曲同工之处，当然，各自也有各自的优缺点，这和他们各自的应用场景有很大的关系。</p></div> <h3 id="共同之处"><a href="#共同之处" class="header-anchor">#</a> 共同之处</h3> <p>两者在开发阶段，从项目架构上，<strong>代码库</strong> 都按照 <code>应用</code> 进行拆分，各自研发各自的，互相不冲突。</p> <h3 id="不同之处"><a href="#不同之处" class="header-anchor">#</a> 不同之处</h3> <p>两者最大的不同之处，先从 <code>通信</code> 说起吧。</p> <h4 id="微服务通信"><a href="#微服务通信" class="header-anchor">#</a> 微服务通信</h4> <p>微服务，每个应用启动时，除了采用 <code>http</code> 的方式，还有其他诸如：<code>WS</code> ,  <code>RPC</code> 等，也就是说，他们各自运行各自的服务，除了可以通过 <code>http</code> 进行 调用，还可以通过其他方式进行互通，我了解的比较经典的就是 <code>RPC</code> 了，据说这个玩意，可以像 本地调用 一样 进行调用 远程机器 上的代码，这是什么意思呢？</p> <p>比如前端开发中的 <code>npm</code> 包，你想用一个包，你需要 <code>npm install packageName</code> 安装到你的本地，然后你才能 <code>import</code> or <code>require</code> 对吧？</p> <p>但是，<code>RPC</code> 不用，人家可以通过指定的语法方式，直接去调用远端啊，调用的代码根本不需要在本地机器，还避免了像 <code>http</code> 方式进行几次握手传输所带来的性能浪费问题。其实有点像前端的 <code>import()</code> ，因为 <code>import()</code> 函数的参数，可以是一个 资源的远端地址。</p> <h4 id="微开发通信"><a href="#微开发通信" class="header-anchor">#</a> 微开发通信</h4> <p>微开发，每个应用启动时，或者启动之前，是先把 依赖 的其他应用或底层应用，通过特定手法 注入 到当前应用中，就像你常用到的包管理器，先把包安装到应用中，再进行引入调用，所以，微开发没有各个应用之间通信的问题，因为启动时，已经把依赖的服务，通过特定手法 进行了应用组装，一起部署。</p> <h3 id="对比分析"><a href="#对比分析" class="header-anchor">#</a> 对比分析</h3> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>两者的对比分析，我们暂且从两个维度 <code>开发阶段</code> 和 <code>部署阶段</code> 进行 简单的 <strong>大致</strong> 说明一下。</p></div> <h4 id="开发阶段"><a href="#开发阶段" class="header-anchor">#</a> 开发阶段</h4> <p>项目代码仓库，两种都是独立，没啥可说的。</p> <p>通信：</p> <ul><li>微服务，可以通过其他方式，直接进行调用通信，应用自身 的代码仓库无需变动，看起来比较优雅。</li> <li>微开发，注入依赖的应用到自身应用进行调用，应用自身 的代码仓库上，视觉上看起来比较凌乱。</li></ul> <h4 id="部署阶段"><a href="#部署阶段" class="header-anchor">#</a> 部署阶段</h4> <p>通信：</p> <ul><li>微服务，当调用通信的 <code>目标应用</code> 时，如果 <code>目标应用</code> 服务挂掉，那么所有的 <code>调用者</code> 都将失败，当然一般用户量比较大的应用，都会有或大或小的集群，来负载或避免这种问题。<div class="custom-block warning"><p class="custom-block-title">注意</p> <p><strong>但是呢，如果 <code>目标应用</code> 的代码层面，提交了致命的错误，那么服务肯定起不来，直接挂掉，那么所有的 <code>调用者</code> 就真的毫无办法了</strong>。</p></div></li> <li>微开发，视觉上，虽然看起来是稍微凌乱了一些，但最终，依赖的 <code>应用</code> 不会被提交到 <code>自身应用</code> 的仓库中，因为被忽略掉，也是可以接受。<div class="custom-block tip"><p class="custom-block-title">注意</p> <p>并且，因为启动前先进行了注入，那么，<code>N个应用</code> 启动前，先把 <code>依赖的应用</code> 进行 <code>注入</code>（等同于源码复制），那么当 <code>依赖的应用</code> 提交了致命错误时，<code>N个应用</code> 只需要不更新 <code>依赖的应用</code> 即可避免。</p></div></li></ul> <h2 id="拓展延伸"><a href="#拓展延伸" class="header-anchor">#</a> 拓展延伸</h2> <p>上面大多场景，看起来是针对 <code>业务层面</code> ，其实反过来想，<code>微开发</code> 只是一个模式，或者说是一个模块化更加抽象的方式，所以抽象实现了，那么抽出来的是什么，想抽出来什么，那不就看你自己了，只要觉得合理，<code>即</code> <code>可</code> <code>抽</code> 。</p> <p>就拿前端举例子，最常见的莫过于 <code>npm package</code> 了，或者 <code>cnpm</code> 私服等，这些干的事，统统可以利用 <code>微开发</code> 模式，进行管理，那么问题来了，为什么要用 <code>微开发</code> 来做 <code>npm/cnpm</code> 的事，这里要特别说明一下，不是替代，而是 <strong>分段</strong> ,下面从客观角度解释一下吧。</p> <h3 id="npm-cnpm"><a href="#npm-cnpm" class="header-anchor">#</a> npm/cnpm</h3> <p>他们俩，都有 公服 和  私服。</p> <ul><li>公服：就是对外公开，大家都可以访问，可以使用。</li> <li>私服：就是内网或公司团队内部搭建部署，只有团队内部公开。</li></ul> <p><strong>但是，有一个致命问题，也是前端界都知道的问题：npm 其实最适合的场景是发布一些成熟的包。</strong> 那么，何为成熟的包呢？</p> <ul><li>高质量</li> <li>高拓展</li> <li>高通用</li> <li>低可变</li></ul> <p><strong>简单来讲：在一个内部项目组和内部团队中，这个包要绝对通用，而且适合场景要考虑的周全，稳定性，质量等各方面要求也高。</strong></p> <p><strong>不然的话：你写了一个包，迭代频繁，再使用的时候，出现了问题，调试是极其的麻烦，而且使用者还可能没有调试源码的权限，难道要去 node_modules 去调？这很不现实。</strong></p> <p><strong>所以其实：npm 更实用的场景是生产环境，就比如一些开源库，他们开源发布之前，研发的过程中，大部分应该都不是从头开始使用 npm ，而是以源码的方式使用，经历了N个版本或N个项目使用稳定之后，最终开源发布 npm。</strong></p> <h3 id="微开发"><a href="#微开发" class="header-anchor">#</a> 微开发</h3> <p>上面提到了 <code>npm</code> 的场景更适合生产环境，那么在你的包还没有达到生产的要求之前呢？其实完全可以使用 <code>微开发模式</code> 在开发阶段，代替 <code>npm</code> 作为内部包管理器，待经历几个版本几个项目之后，达到一定的稳定性，通过自动化脚本一键发布到 <code>npm</code>。</p> <h2 id="大道至简"><a href="#大道至简" class="header-anchor">#</a> 大道至简</h2> <p>当对业务进行了拆分实现之后，其实大概可以得出结论：</p> <ul><li>拆分，或者拆库，只是一种思想或模式。</li> <li>不局限框架，Vue，React，Angular（只要有对应的解析插件），甚至不局限于语言（如果有语言之间互通的工具的话）。</li> <li><code>应用之间</code> 的依赖注入：一是仓库之间的依赖注入；二是业务之间的组合拼装。</li></ul> <h2 id="技术实现"><a href="#技术实现" class="header-anchor">#</a> 技术实现</h2> <p>以 Vue 项目实现案例举例，流程大致如下。</p> <h3 id="源码-依赖-管理器"><a href="#源码-依赖-管理器" class="header-anchor">#</a> 源码 依赖 管理器</h3> <p>注意上面标题中的 <code>源码</code> ，而不是 <code>包</code> ，从通常开源方面讲，一个<code>包</code> 往往都包含 <code>源码</code> 。
比如最常见的前端在开发 <code>js</code> 包时，往往都是在使用 <code>ES6+</code>，<code>TypeScript</code>，或者早期的 <code>CoffeeScript</code> ，来进行编写，最终通过编译器编译输出 浏览器能识别的 <code>es5</code> 代码，且暴露导出的也是 <code>es5</code> 代码。</p> <p><strong>现在我们使用 git 仓库作为包个体，引用的也是仓库中的源码，所以称之为：<code>源码依赖管理器</code></strong>。</p> <p>对于 <code>源码依赖管理器</code> ，开发了一个脚手架工具，就像 管理npm包一样的方式，来管理基于Git仓库的依赖操作。<a href="/cli">脚手架</a></p> <h3 id="实现依赖管理的必备条件"><a href="#实现依赖管理的必备条件" class="header-anchor">#</a> 实现依赖管理的必备条件</h3> <ol><li>底层模块仓库
<ul><li>配置层面：对全局组件，指令，过滤器，插件，工具方法的初始化，挂载</li> <li>应用层面：Router初始化，Store初始化，Services等其他</li> <li>编译层面：webpack 通用配置</li> <li>导出入口：把当前仓库需要暴露的东西导出去</li></ul></li> <li>每个应用仓库
<ul><li>注入：通过脚手架把依赖的 底层模块，注入到当前仓库中的指定位置（这个注入的位置的入口是被主应用仓库git忽略掉的，就像node_modules目录被忽略掉一样</li> <li>初始化： 底层模块 的配置初始化，应用初始化，编译配置</li> <li>组合：导入 底层模块 的导出入口，和 自身应用中进行组合（如果应用拆分的更加细粒度，这里就是进行把各个应用组合的入口）</li></ul></li></ol> <h3 id="仓库之间依赖注入的实现解决了什么问题？"><a href="#仓库之间依赖注入的实现解决了什么问题？" class="header-anchor">#</a> 仓库之间依赖注入的实现解决了什么问题？</h3> <ol><li>仓库都分开了，其他的业务中写了致命的错误，和我啥关系呢？</li> <li>不同业务上线日期不同，对 “底层业务” 维护？既然 “底层业务” 是一个独立仓库，那必然可以充分利用 git 的branch 功能，比如：A应用 5月10号上线，B应用 5月15号上线，B应用 需要对 底层 某个业务进行紧急调整，而 A应用 不需要，或者待定，在之前的结构里面，需要通过各种环境变量，进行动态判断，来控制。现在，只需要在底层仓库新开一个紧急分支，B应用 注入这个紧急分支，而 A应用 依然注入主分支即可。（这只是其中一个例子，实际项目中，还会有更为特殊复杂的需求导致难以管理）</li> <li>对于底层模块的维护
<ul><li>底层模块 维护人员正常迭代</li> <li>每个业务应用，因为注入的是源码，并且是以 Git 为个体单位 存放在应用中，那么，业务应用开发者，在碰到底层模块问题时，可以直接在注入的仓库中，进行修改，调试，这种修改调试，是完全基于当前业务所使用的真实场景，而相对模拟场景来说，代码的稳定质量效率上，是一个大的提升。并且，调试修改完了，如果你被授予底层业务仓库的写权限，你可以直接进行对底层模块的Git提交，而且，和主业务应用的Git是完全分开无冲突，仅仅是视觉上看起来是仓库嵌套仓库，操作上，完全独立。</li> <li>基于上面这条，当前项目中的 “公用资源” 如何共享给团队使用？既然在业务层面实现了依赖注入甚至包括现场应用场景的迭代，那么对于 “公共资源” 来讲，区别仅仅是：仓库中存放的内容不同而已，其他项目如需使用，同理，注入，引入，如果被授予权限，也可以进行拓展迭代。</li></ul></li></ol> <h3 id="编译-发布-部署"><a href="#编译-发布-部署" class="header-anchor">#</a> 编译&amp;&amp;发布&amp;部署</h3> <p>通过上面的方式，基本可以看出来，在发布之前，依赖的底层模块已被注入到业务仓库，那么在编译发布时，等同于把自身业务和依赖的业务一起打包编译发布。
每个业务发布之后的部署结果，都是纯粹的自身业务，这一点，刚好和微服务相反，也是在本文最初提到 “摒弃了微服务模式独立发布部署之后利用 “网关” 面向客户端请求进行路由转发的层面，来以此避免各个 “应用” 之间的耦合问题” 的实现方式。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/micro-development/edit/master/concept.md" target="_blank" rel="noopener noreferrer">来一起改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">7/26/2020, 3:39:59 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.921ab5f8.js" defer></script><script src="/assets/js/2.f6d0a541.js" defer></script><script src="/assets/js/7.1e601e68.js" defer></script>
  </body>
</html>
